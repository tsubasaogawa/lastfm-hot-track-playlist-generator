package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/tsubasaogawa/lfm2ytm/lastfm"
	"github.com/tsubasaogawa/lfm2ytm/ytmusic"
)

var (
	VERSION        string
	REVISION       string
	LASTFM_API_KEY string
)

func main() {
	var (
		secret    = flag.String("secretjson", "./client_secret.json", "Google client secret json file")
		title     = flag.String("title", "Last.fm Hot Tracks", "YouTube (Music) playlist title")
		desc      = flag.String("description", "Generated by lastfm-hot-track-playlist-generator", "YouTube (Music) playlist description")
		privacy   = flag.String("privacy", "private", "YouTube (Music) playlist privacy")
		from      = flag.String("fromdate", "2023-01-01T00:00:00+09:00", "Last.fm target from date")
		to        = flag.String("todate", "2023-01-07T23:59:59+09:00", "Last.fm target to date")
		duplicate = flag.Bool("duplicate", false, "Allow duplicate playlists with the same title")
		region    = flag.String("region", "JP", "Region code used in YouTube (Music) search")
		lfmMax    = flag.Int("lfmmax", 5, "Max results for Last.fm response")
		ytmMax    = flag.Int64("ytmmax", 3, "Max results for YouTube (Music) response")
		maxSearch = flag.Int("maxsearch", 1, "Try count to call api for searching an art track video")
		dryrun    = flag.Bool("dryrun", false, "Do not generate a playlist but fetch a weekly chart")
	)
	flag.Parse()

	args := flag.Args()
	if len(args) != 1 || args[0] == "" {
		log.Fatalln("Give user as an argument")
	}
	user := args[0]

	apikey := os.Getenv("LASTFM_API_KEY")
	if apikey == "" {
		apikey = LASTFM_API_KEY
	}
	var chart lastfm.WeeklyTrackChart
	if err := chart.Fetch(user, apikey, str2unixtime(*from), str2unixtime(*to), *lfmMax); err != nil {
		log.Fatalln(err)
	} else if len(chart.Tracks) < 1 {
		log.Fatalln("No tracks found in given date range")
	}
	if *dryrun {
		for _, tr := range chart.Tracks {
			tr.Print()
			print("\n")
		}
		os.Exit(0)
	}

	svc, err := ytmusic.NewService(*secret)
	if err != nil {
		log.Fatalln(err)
	}

	pl, err := ytmusic.NewPlaylist(svc, *title, *desc, *privacy, *duplicate, *ytmMax)
	if err != nil {
		log.Fatalln(err)
	}

	srch := ytmusic.NewSearch(svc)
	srch.RegionCode = *region
	srch.MaxTries = *maxSearch
	for _, tr := range chart.Tracks {
		tr.Print()
		srch.Q = fmt.Sprintf("%s - %s", tr.ArtistName, tr.Name) // YouTube search query
		item, err := srch.Do()
		if err != nil {
			log.Fatalln(err)
		}
		fmt.Printf("\râœ” %s - %s (%d times; id=%s)\n",
			item.Title, item.Artist, tr.Playcount, item.Id)
		if err = pl.AddItem(item); err != nil {
			log.Fatalln(err)
		}
	}
}

func str2unixtime(date string) int64 {
	parsed, err := time.Parse("2006-01-02T15:04:05Z07:00", date)
	if err != nil {
		log.Fatalln(err)
	}

	return parsed.Unix()
}
